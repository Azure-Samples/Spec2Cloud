name: Index Spec Templates

on:
  push:
    branches:
      - main
    paths:
      - 'TEMPLATES.md'
  schedule:
    # Run every hour
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  index-templates:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout main branch
        uses: actions/checkout@v4
        with:
          ref: main
          
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: Install dependencies
        run: |
          npm install -g js-yaml node-fetch
          
      - name: Process templates and generate JSON
        run: |
          node << 'EOF'
          const fs = require('fs');
          const yaml = require('js-yaml');
          const https = require('https');
          const { execSync } = require('child_process');

          // Function to fetch content from URL
          function fetchUrl(url) {
            return new Promise((resolve, reject) => {
              https.get(url, (res) => {
                let data = '';
                res.on('data', (chunk) => data += chunk);
                res.on('end', () => resolve(data));
              }).on('error', reject);
            });
          }

          // Function to extract repo path from GitHub URL
          function getRepoPath(repoUrl) {
            const match = repoUrl.match(/github\.com\/([^\/]+\/[^\/]+)/);
            return match ? match[1] : null;
          }

          // Function to get repository information (last commit date and stars)
          function getRepoInfo(repoPath) {
            const info = {
              lastCommitDate: null,
              stars: 0
            };
            
            try {
              // Get last commit date
              const commitsUrl = `https://api.github.com/repos/${repoPath}/commits?per_page=1`;
              const commitsResult = execSync(`curl -s -H "Accept: application/vnd.github.v3+json" "${commitsUrl}"`, {
                encoding: 'utf-8'
              });
              const commits = JSON.parse(commitsResult);
              if (commits && commits[0] && commits[0].commit && commits[0].commit.committer) {
                info.lastCommitDate = commits[0].commit.committer.date;
              }
              
              // Get repository stars
              const repoUrl = `https://api.github.com/repos/${repoPath}`;
              const repoResult = execSync(`curl -s -H "Accept: application/vnd.github.v3+json" "${repoUrl}"`, {
                encoding: 'utf-8'
              });
              const repoData = JSON.parse(repoResult);
              if (repoData && repoData.stargazers_count !== undefined) {
                info.stars = repoData.stargazers_count;
              }
            } catch (error) {
              console.error(`Error fetching repo info for ${repoPath}:`, error.message);
            }
            
            return info;
          }

          // Function to extract front matter from markdown
          function extractFrontMatter(content) {
            const frontMatterRegex = /^---\s*\n([\s\S]*?)\n---/;
            const match = content.match(frontMatterRegex);
            
            if (!match) {
              return null;
            }
            
            try {
              return yaml.load(match[1]);
            } catch (error) {
              console.error('Error parsing YAML:', error.message);
              return null;
            }
          }

          // Function to parse array from YAML string
          function parseArray(value) {
            if (Array.isArray(value)) {
              return value;
            }
            if (typeof value === 'string') {
              // Remove brackets and split by comma
              return value.replace(/[\[\]]/g, '').split(',').map(item => item.trim()).filter(item => item);
            }
            return [];
          }

          // Main processing function
          async function processTemplates() {
            console.log('Reading TEMPLATES.md...');
            const templatesContent = fs.readFileSync('TEMPLATES.md', 'utf-8');
            
            // Extract URLs from the markdown file
            const urlRegex = /https:\/\/github\.com\/[^\s\)]+/g;
            const repoUrls = templatesContent.match(urlRegex) || [];
            
            console.log(`Found ${repoUrls.length} repository URLs`);
            
            const templates = {};
            
            for (const repoUrl of repoUrls) {
              const cleanRepoUrl = repoUrl.replace(/\.git$/, '');
              const repoPath = getRepoPath(cleanRepoUrl);
              
              if (!repoPath) {
                console.log(`Skipping invalid repo URL: ${repoUrl}`);
                continue;
              }
              
              console.log(`Processing: ${repoPath}`);
              
              // Construct raw GitHub URL for SPEC2CLOUD.md
              const rawUrl = `https://raw.githubusercontent.com/${repoPath}/main/SPEC2CLOUD.md`;
              
              try {
                // Fetch the SPEC2CLOUD.md content
                console.log(`  Fetching: ${rawUrl}`);
                const content = await fetchUrl(rawUrl);
                
                // Extract front matter
                const metadata = extractFrontMatter(content);
                
                if (!metadata) {
                  console.log(`  ⚠️  Skipping ${repoPath}: No front matter found in SPEC2CLOUD.md`);
                  continue;
                }
                
                // Validate mandatory fields
                const mandatoryFields = ['title', 'description', 'category', 'industry'];
                const missingFields = mandatoryFields.filter(field => !metadata[field]);
                
                if (missingFields.length > 0) {
                  console.log(`  ⚠️  Skipping ${repoPath}: Missing mandatory fields: ${missingFields.join(', ')}`);
                  continue;
                }
                
                // Get repository info (last commit date and stars)
                const repoInfo = getRepoInfo(repoPath);
                
                // Generate template ID from repo name
                const templateId = repoPath.split('/')[1].toLowerCase().replace(/[^a-z0-9-]/g, '-');
                
                // Build template object
                const template = {
                  title: metadata.title,
                  description: metadata.description,
                  repo: metadata.repo || cleanRepoUrl,
                  authors: parseArray(metadata.authors),
                  category: metadata.category,
                  industry: metadata.industry,
                  stars: repoInfo.stars,
                };
                
                // Add optional fields if present
                if (metadata.services) {
                  template.services = parseArray(metadata.services);
                }
                if (metadata.languages) {
                  template.languages = parseArray(metadata.languages);
                }
                if (metadata.frameworks) {
                  template.frameworks = parseArray(metadata.frameworks);
                }
                if (metadata.tags) {
                  template.tags = parseArray(metadata.tags);
                }
                if (metadata.thumbnail) {
                  template.thumbnail = metadata.thumbnail;
                }
                if (metadata.video) {
                  template.video = metadata.video;
                }
                if (metadata.version) {
                  template.version = metadata.version;
                }
                if (repoInfo.lastCommitDate) {
                  template['last-commit-date'] = repoInfo.lastCommitDate;
                }
                
                templates[templateId] = template;
                console.log(`  ✓ Successfully processed ${templateId} (${repoInfo.stars} stars)`);
                
              } catch (error) {
                console.log(`  ⚠️  Skipping ${repoPath}: ${error.message}`);
                continue;
              }
            }
            
            // Write templates.json
            const outputPath = 'templates.json';
            fs.writeFileSync(outputPath, JSON.stringify(templates, null, 2));
            console.log(`\n✓ Generated ${outputPath} with ${Object.keys(templates).length} templates`);
            
            return Object.keys(templates).length;
          }

          // Run the process
          processTemplates().catch(error => {
            console.error('Error:', error);
            process.exit(1);
          });
          EOF
          
      - name: Checkout pages branch
        uses: actions/checkout@v4
        with:
          ref: pages
          path: pages-branch
          
      - name: Copy templates.json to pages branch
        run: |
          mkdir -p pages-branch/docs
          cp templates.json pages-branch/docs/templates.json
          
      - name: Commit and push to pages branch
        run: |
          cd pages-branch
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add docs/templates.json
          
          # Only commit if there are changes
          if git diff --staged --quiet; then
            echo "No changes to templates.json"
          else
            git commit -m "Update templates.json [automated]"
            git push
            echo "✓ Successfully updated templates.json on pages branch"
          fi
